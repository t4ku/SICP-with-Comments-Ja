;1.2.3 Order of Growth

;計算リソースを消費する割合が処理によって大きく異なる事をこれまで例示して
;きた。このような違いを記述するためには、計算量(Order of Growth)を使用して
;入力が大きくなるにつれて総体的なリソースがどれくらい必要になるか計ると
;わかりやすい。

;nを問題の大きさを測るパラメーターとして、その問題のサイズを書類するために
;必要なリソースの量をR(n)とする。先ほどの例ではnを特定の関数が呼び出される
;回数としたが、他の値をnとする事も出来る。例えば、もしある数字の平方根
;の近似値を計算したい場合、nを結果に必要な精度の桁数としてもよい。
;行列乗算であればnを行列の行数としてもよい。一般的に、一つの問題には
;プロセスを分析することが望ましいと思われる観点から見た、様々な属性が存在する。

;同様に、R(n)は内部記憶のレジスタの数であるかもしれないし、基本となる
;マシンレベルの命令の実行回数やその他の数であるかもしれない。同時に実行する命令
;が一定であるコンピューターでは、必要な処理時間はマシンレベルの命令の実行回数
;に比例する。


;k1とk2がnとは独立に正の定数をとり、

;k1*f(n) ≦ R(n) ≦ k2*f(n)

;(別の言い方をすれば、R(n)がk1*f(n)とk2*f(n)に間にある)が
;いかなる十分に大きな数値nについても成り立つ場合、
;R(n) = Θ(f(n))と記述し、
;「計算量R(n)はΘ(f(n))の増加オーダーを持つ』という。

;(つまり、計算量の増加オーダーを示す式を求めるためには、
;nという計算量の入力パラメーターを使った想定の式を出してみて、
;nがどのような値をとっても、R(n)が「定数1*(想定の式)」と「定数2*(想定の式)」
;の間に収まるような、定数1および定数2が存在すれば、想定の式が増加オーダーを表す)

;例えば、1.2.1で記述した階乗を求める線形再帰の手続きでは、
;処理のステップ数は入力nに比例して増加する。従って、プロセスに
;必要なステップはΘ(n)で増加する。必要なスペースもΘ(n)で増加する。
;また、反復的に階乗を求めるやり方でも処理のステップはΘ(n)だが、
;必要とするスペースは状態変数のみなのでΘ(1)である。

;木構造再帰で求めるフィボナッチ数の計算においては、
;増加オーダーは、Φが1.2.2で記述される黄金律とすると
;ステップ数でθ(Φ^n)でスペースはθ(n)である。

;増加オーダーはプロセスの振る舞いの大雑把な記述にしかならない。
;例えば、n^2を要するプロセスも1000*^2を要するプロセスも3n^2 + 10n + 17ステップ
;を要するプロセスも、いずれもθ(n^2)の増加オーダーである。一方で、
;問題のサイズを変化させていった場合に、どのようにプロセスの振る舞いが変わる
;を理解するために有用な指標となる。
;θ(n)つまり線形のプロセスでは、問題のサイズを2倍にするとおよそ
;2倍のリソースが使用される。指数関数であれば、問題の大きさが一つ
;増えるとリソースの使用が定数の2乗倍となる。

;Exercise 1.14 

;問題

;上記のcount-changeで11セントを両替する組み合わせを求めるプロセスの
;木構造を記述せよ。また、対象となる金額が増加するにしたがって、スペースと
;ステップ数はどのようなオーダーで増加するか。

;回答

;(count-change 11)

;(cc 11 5)

;  (cc 11 4)
;+ 
;  (cc -39 5)


;                                                         (cc 11 0) = 0
;                                            (cc 11 1) +  
;                                                                     (cc 10 0) = 0
;                                                         (cc 10 1) +
;                                                                                 (cc 9 0) = 0
;                                                                     (cc  9 1) +
;                                                                                            (cc 8 0) = 0
;                                                                                 (cc 8 1) +
;                                                                                                       (cc 7 0) = 0
;                                                                                            (cc 7 1) +
;                                                                                                                  (cc 6 0) = 0
;                                                                                                       (cc 6 1) + 
;                                                                                                                             (cc 5 0) = 0
;                                                                                                                  (cc 5 1) +
;                                                                                                                                        (cc 4 0) = 0
;                                                                                                                             (cc 4 1) +
;                                                                                                                                                   (cc 3 0) = 0
;                                                                                                                                        (cc 3 1) +
;                                                                                                                                                              (cc 2 0) = 0
;                                                                                                                                                   (cc 2 1) +
;                                                                                                                                                                         (cc 1 0) = 0
;                                                                                                                                                              (cc 1 1) +
;                                                                                                                                                                         (cc 0 1) = 1
;
;                              (cc 11 2)  +  
;                                                                     (cc 6 0)  = 0
;                                                         (cc 6  1) +
;                                                                                 (cc 5 0) = 0
;                                                                     (cc 5 1)  +
;                                                                                            (cc 4 0) = 0
;                                                                                 (cc 4 1) +
;                                                                                                       (cc 3 0) = 0
;                                                                                            (cc 3 1) + 
;                                                                                                                  (cc 2 0) = 0
;                                                                                                       (cc 2 1) +
;                                                                                                                             (cc 1 0) = 0
;                                                                                                                  (cc 1 1) +
;                                                                                                                             (cc 0 1) = 1
;                                            (cc 6  2) +
;                                                                                 (cc 1 0) = 0
;                                                                     (cc 1 1)  + 
;                                                                                 (cc 0 1) = 1
;                                                         (cc 1  2) +
;                                                                     (cc -4 2) = 0
;                (cc 11 3)  + 
;                                                                     (cc  1 0) = 0
;                                                         (cc 1  1) +
;                                                                     (cc  0 1) = 1
;                                            (cc 1  2) +
;                                                         (cc -4 2) = 0
;                              (cc  1 3)  +
;                                            (cc -9 3) = 0
;  (cc 11 4)   +
;                (cc -14 4) = 0
;+ 
;  (cc -39 5)  = 0

;ステップ数は節の数、スペースは根の深さの最大値である。
;したがって、上記の演算は55のステップから成り立つ。

;nの金額で5種類のコインを使用した場合、ステップの数は
;下記の3つの数の合計である。

; - 1
; - (cc n 4)から派生する子ノードの数
; - (cc (-n 50) 5)から派生する子ノードの数

;(cc n m)、つまり金額nをm種類のコインで両替する手続き、に要するステップ数を
;N(n,m)で表すとすると、上記の関係は下記のように表せられる。

;N(n,5) = 1 + N(n,4) + N(n-50,5)
;N(n,4) = 1 + N(n,3) + N(n-25,4)
;N(n,3) = 1 + N(n,2) + N(n-10,3)
;N(n,2) = 1 + N(n,1) + N(n-5 ,2)
;N(n,1) = 1 + N(n,0) + N(n-1 ,1)

;ここでN(n,0)はccの手続きにおいて0に条件分岐するだけ、つまりステップ数1であるから
;N(n,0) = 1
;よって、
;N(n,1) = 1 + 1 + N(n-1,1)
;さらに、N(n-1,1)も
;N(n-1,1) = 1 + N(n-1,0) + N(n-2,1)
;N(n-1,1) = 1 + 1        + N(n-2,1)
;というように解決でき、最終項がN(n-n,1)となるまで繰り返される。

;N(n-n,1) = 1であるから、ここから逆方向に
;N(n-(n-1),1) = 1 + 1 + 1 = 3
;N(n-(n-2),1) = 1 + 1 + 3 = 5
;N(n-(n-3),1) = 1 + 1 + 5 = 7
;
;n回繰り返したときのステップ数は
;N(n-(n-n)    ,1) = 1 + 2n
;つまり、N(n,1) = 2n + 1

;スペースは根の深さの最大値であり、(cc n 1)が(cc n 2)..(cc n 5)よりも根が深い
;節を作り出すことから、スペースはθ(n)といえる。つまり線形に増える

;一方、ステップ数に関してはN(n,1) = 2n-1まで求める事ができた。

;N(n,2) = 1 + N(n,1) + N(n-5,2)
;についてN(n-5,2)を展開していくと
;
;N(n-5,2) = 1 + N(n-5,1) + N(n-10,2)
;         = 1 + N(n-5,1) + 1 + N(n-10,1) + N(Nn-15,2)
;         = 1 + N(n-5,1) + 1 + N(n-10,1) + 1 + N(n-15,1) + N(n-20,2)
;         = 1 + N(n-5,1) + 1 + N(n-10,1) + 1 + N(n-15,1) + 1 + N(n-20,1) + N(n-25,2)
;         ...

;展開はn/5回行われ、それぞれN(a 1)の形式の項が生み出されるため2n + 1のステップ数を要する。
;オーダーは係数を無視するため、nのオーダーの展開がn/5回行われると考え、最終的な
;N(n,2)のオーダーはn * n/5 = n^2 / 5

;次に、N(n,3)に同じ展開を適応してみる

;N(n,3) = 1 + N(n,2) + N(n-10,3)
;       = 1 + N(n,2) + 1 + N(n-10,2) + N(n-20,3)
;       = 1 + N(n,2) + 1 + N(n-10,2) + 1 + N(n-20,2) + N(n-30,3)
;       ...
;
;展開はn/10回行われ、n^2/5のオーダーの演算が行われるため、
;N(n,3)のオーダーは n/10 * n^2/5 = n^3 / 50

;N(n,4)とN(n,5)にも同じ展開を行いオーダーを求めればよいが、係数は無視できるので
;乗数が一ずつ増えると考えられる。
;したがって、N(n,5)のステップ数のオーダーはn^5となる。
;つまり、θ(n^5)となる。


;Exercise 1.15

;問題
;ある角度のsin値を計算する方法に、xが十分に小さければsin x ≈ xであるという推定
;を用い、三倍角公式
;sin r = 3sin(r/3) - 4sin^3(r/3)
;をsinの引数であるrを減少させていくために使用する。
;
;※"xが十分に小さい"とはここではラジアンが0.1以下であることをさす

;こうした考えを手続きにしたものが下記である。

(define (cube x)(* x x x))
;(define (p x)(- (* 3 x)(* 4 (cube x))))
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))

;a. (sine 12.15)が評価されるとき手続きpは何回呼び出されるか
;b. (sine a)が評価されるとき、sineという手続きによって生成される
;   プロセスで使用されるスペースとステップ数が増えるオーダーは何か？

;回答
;a.
;まず手続きpが呼び出された回数を表示できるようにする
(define (p x)
  (print 1) 
  (- (* 3 x)(* 4 (cube x))))
(print (sine 12.15))

;463 (print (sine 12.15))
;1
;1
;1
;1
;-0.39980345741334        

;従って、5回呼び出されている事が分かる

;置き換えモデルを使って展開してみる

;(sine 12.15)
;(p (sine (/ 12.15 3.0)))
;(p (sine 4.05))
;(p (p (sine (/ 4.05 3.0))))
;(p (p (sine 1.35)))
;(p (p (p (sine (/ 1.35 3.0)))))
;(p (p (p (sine 0.45))))
;(p (p (p (p (sine (/ 0.45 3.0))))))
;(p (p (p (p (sine 0.15)))))
;(p (p (p (p (p (sine (/ 0.15 3.0)))))))
;(p (p (p (p (p (sine 0.05))))))
;(p (p (p (p (p 0.05))))

;上記からもpが5回適応されているのがわかる。

;b.

;sineは引数が0.1以内になるまで引数を3で割っていくため、
;その展開の回数は引数の値のlog3回となる。
;また、p内のオーダーと容量は一定でθ(1)となるため、
;sineによって生成されるプロセスのスペースとステップ数の
;オーダーはいずれもθ(logn)となる。
