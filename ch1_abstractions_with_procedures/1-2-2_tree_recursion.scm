;1.2.2 木構造再帰

;典型的な演算のパターンには他にも、木構造再帰と呼ばれるものがある。
;例えば、数字が前の二つの合計となるように連なる数列であるフィボナッチ数を
;例に考えてみる。

;0,1,1,2,3,5,8,13,21...

;一般的にフィボナッチ数は下記のルールで定められる

;Fib(n) = 0                   if n = 0
;         1                   if n = 1
;         Fib(n-1) + Fib(n-2) otherwise

;このルールに従って、フィボナッチ数を求める
;手続きは簡単にかける

(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else(+ (fib (- n 1))
                 (fib (- n 2))))))

;(fib 5)の処理の流れは下記のようになる。

;(fib 5)
;(+ (fib 4)(fib 3))
;(+ (+ (fib 3)(fib 2))(+ (fib 2)(fib 1)))
;(+ (+ (+ (fib 2)(fib 1))(+ (fib 1)(fib 0))(+ (+ (fib 1)(fib 0))(+ (fib 1)(fib 0)))))
;(+ (+ (+ (+ (fib 1)(fib 0))(fib 1))(+ (fib 1)(fib 0))(+ (+ (fib 1)(fib 0))(+ (fib 1)(fib 0)))))

;これは下記の木構造で表せる

;                                        fib 1
;                            fib 2 = +
;                                        fib 0
;                fib 3 = +
;                            fib 1
;    fib 4 = +
;                            fib 1
;                fib 2 = +
;                            fib 0
;+
;                            fib 1
;                fib 2 = +  
;                            fib 0
;    fib 3 = +
;                fib 1

;この演算のパターンを考えると、(fib 5)を求めるために(fib 4)と(fib 3)が必要だ。
;(fib 4)を求めるためには(fib 3)(fib 2)が必要だ。一般的に、これは上記の木構造
;のように進化する。末端以外のすべての節は2つに分岐する。これはfibという手通続き
;が呼び出されるたびに二回自分自身を呼び出すことを示している。

;この手続きは典型的な木構造の再帰として分かりやすいが、演算が冗長であるため
;フィボナッチ数の計算方法としてはひどいやり方だ。例えば(fib 3)は二回行われている。
;実際(fib 1)や(fib 0)の呼び出し回数がFib(n+1)※末端の数　であることは簡単に分かる。

;これがどれくらいひどいかを示すために、Fib(n)が指数関数的に増大すると言ってもいい。
;もっと性格にいうとFib(n)はΦが下記の条件を満たす時の、Φ^n/√5に近似する整数である。
;Φ = (1 + √5) / 2 ≈ 1.6180、つまり黄金比であり、 Φ^2 = Φ + 1を満たす。

;したがって、処理は入力に応じて指数関数的に増加するステップ数が必要となる。
;一方で、演算のいかなる段階においても上位の節がどれであるかさえ捕捉しておけばよいので、
;記憶すべき内容は入力に線形にしか増加しない。一般的に、木構造の再帰手続きでは演算に
;必要なステップ数は木の節の数に比例し、記憶すべき内容は木構造の深さの最大値に比例する。

;フィボナッチ数の演算について、反復的手続きを公式化する事もできる。
;考え方は、aとbという対になる整数を使用し、Fib(1) = 1、Fib(0) = 0で初期化し、
;下記の変形を同時に適応していく

;a <- a + b
;b <- a

;n回適応したあとaとbはそれぞれFib(n+1),Fib(n)となることは想像に難くない。
;したがって、下記の手続きを使用すればフィボナッチ数を反復的に演算できる。

(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b n)
  (if (= n 0)
       b 
       (fib-iter (+ a b) a (- n 1))))

;この二番目の手続きは線形反復という。
;最初に定義したfibと、上記のfibにおける必要となるステップ数の違いは小さな値が入力で
;あったとしても非常に大きなものとなる。

;これをもって、木構造の再帰手続きは無用と断定すべきではない。
;数値でなく階層構造のデータを処理することを検討するとき、木構造の再帰手続き
;は自然で強力なツールとなる。また、数値に対して処理を行う場合でも、
;プログラムを理解し設計する際に木構造の再帰手続きは役にたつ。
;例えば、最初のfibという手続きは2番目の手続きに比べ、演算効率からいうと大いに非効率
;だが、ほとんどフィボナッチ数列をLispの手続き置き換えただけのものなので、直感的に理解しやすい。
;反復アルゴリズムを思いつくには、3つの状態変数を使用して演算を繰り返すことができるということ
;に気づく必要がある。


