;1.2.5 Greatest Common Divisors

;２つの整数aとbの最大公約数(GCD)とは、あまりなしでaとb両方割ることができる最大の整数である。
;例えば16と28の最大公約数は4である。

;(この先)2章で有理数演算をどうやって実装するか調査することになるのだが、
;その時に有理数を既約にするためにGCDを計算する必要が出てくる。
;(有理数を既約にするには、分子と文をそのGCDで割る。例えば 16/28は4/7にする)

;２つの整数のGCDを見つけるやり方の一つは、それぞれを因数分解して
;共通の因数を見つけることだが、より効率的な有名なアルゴリズムがある。

;そのアルゴリズムの考え方は下記の考察に基づいている。

;a / b のあまりがrとした場合、
;aとbの公約数はbとrの公約数と同じになる。

;***
;a = 18, b = 12とすると
;r = 6となる。
;a(=18)とb(=12)の最大公約数 -> 6
;b(=12)とr(=6)の最大公約数  -> 6
;***

;したがって、下記のような等式が成り立つ
;GCD(a,b) = GCD(b,r)

;そして、対となる整数のGCDを求める問題をより
;小さな数のペアのGCDを求める問題に継続的に置き換えていくことができる。
;例えば

;GCD(206, 40) = GCD(40,6)
;             = GCD(6,4)
;             = GCD(4,2)
;             = GCD(2,0)
;             = 2

;上記の変換はGCD(206,40)をGCD(2,0)に減少させる。正の整数２つから初めて
;つねに片方が0にになるまで、ペアの数を減少させていくことを示せる。
;その時GCDはもう片方の数である。このGCDを求める方法をユークリッド互除法とよぶ。

;ユークリッド互除法は簡単に手続きで表現できる。

(define (gcd a b)
  (if (= b 0)
    a
    (gcd b (remainder a b))))

(print "--gcd--")
(print (gcd 18 12))

;これは反復的に増大するプロセスを生成し、ステップ数は
;関連する数に応じて対数的に増加する。

;ユークリッド互除法に必要なステップ数が対数的に増加するというのは
;フィボナッチ数と興味深い関連を生み出している。

;ラメの定理

;ユークリッド互除法がある対のGCDを求めるのにkステップ必要になるとした時、
;より小さい方の対の数はk番目のフィボナッチ数と等しいか、それよりも大きく
;なっている。

;この定理を利用すると、ユークリッド互除法の計算量を見積もるのに使える。
;nを手続きに与える小さい方の数とする。手続きがkステップ要する場合、
;n >= Fib(k) ≒ Φ^k / √5 になるはずだ。したがって手続き数kはnの
;したがって、計算量はΘ(log n)となる。

;Exercise 1.20

;手続きが生成するプロセスはインタプリターで使用される方式よって異なる。
;例えば、反復的な手続きてである上記のgcdについて見てみる。
;この手続を、セクション1.1.5で議論した正規順序で評価すると仮定する
;(ifの正規順序での評価の方式はexercise1.5で記述した)。
;(正規順序のために)置き換えモデルを使用して、(gcd 206 40)を評価する
;際に生成されるプロセスを記述し、実際に行われるremainder演算を示せ。
;(gcd 204 40)を正規順序で評価する際に何回remainder演算は行われるか？
;また作用順序の場合はどうか?

;***
;1.1.5もしくはexercise 1.5を見ればわかるが、
; applicative order(作用的順序)とnormal order (正規順序)の違いは、
; 演算子をどの時点で評価するかの違いだ。
; 作用的順序 -> 演算しと非演算子が評価出来る時点で評価し、手続きの引数に与える。
; 正規順序   -> 演算子と被演算子だけになるまで、展開してから収縮する。
;***

;単純に正規順序で評価してみる

;(gcd 206 40)

;(if (= 40 0)
;  206
;  (gcd 
;    40 
;    (r 
;      206 
;      40)))

;さらにもう一段、gcdをパラメーター置き換えする。

;(if (= 40 0)
;  206
;  (if                        ; gcd展開部
;    (= (r 206 40) 0)  ; このノードはこれ以上展開不可なので、評価できる
;    40
;    (gcd 
;      (r 206 40) 
;      (r 
;        40 
;        (r 206 40)))))

;再度、パラメーター置き換えと評価を行う

;(if (= 40 0)
;  206
;  (if                        
;    (= 6 0)                  ; (= (r 206 40) 0) の評価
;    40
;    (if                      ; gcd展開部
;      (= (r 40 (r 206 40)) 0)  ; 同様にこれ以上展開不可
;      (r 206 40)
;      (gcd 
;        (r 40 (r 206 40))
;        (r 
;          (r 206 40)
;          (r 40 (r 206 40) ))))))

;(if (= 40 0)
;  206
;  (if                        
;    (= 6 0)                  
;    40
;    (if                      
;      (= 4 0)                ; (r 40 (r 206 40)) の評価
;      6
;      (if                    ; gcd展開部
;        (= (r (r 206 40) (r 40 (r 206 40))) 0  
;        (r 40 (r 206 40))
;        (gcd
;          (r (r 206 40) (r 40 (r 206 40)))
;          (r 
;            (r 40 (r 206 40))
;            (r (r 206 40) (r 40 (r 206 40))) )))))))

;(if (= 40 0)
;  206
;  (if                        
;    (= 6 0)                  
;    40
;    (if                      
;      (= 4 0)                
;      6
;      (if                    
;        (= 2 0)              ;(r (r 206 40) (r 40 (r 206 40)))の評価 
;        4
;        (if                  ;gcd展開部
;          (= 
;            (r (r 40 (r 206 40)) (r (r 206 40) (r 40 (r 206 40)))) ;展開不可
;            0)
;          (r (r 206 40) (r 40 (r 206 40)))
;          (gcd
;            (r 
;              (r 40 (r 206 40))
;              (r (r 206 40) (r 40 (r 206 40))) )
;            (r 
;              (r (r 206 40) (r 40 (r 206 40)))
;              (r 
;                (r 40 (r 206 40))
;                (r (r 206 40) (r 40 (r 206 40))) ))))))))

;ここでif文の条件
;(r (r 40 (r 206 40)) (r (r 206 40) (r 40 (r 206 40)))) 
; → 0となるので
;(r (r 206 40) (r 40 (r 206 40)))　が答えとなる。

;したがって、評価してきたif文(と最後の答えの評価)を並べると下記のようになる。
;(r 206 40)
;(r 40 (r 206 40))
;(r (r 206 40) (r 40 (r 206 40)))
;(r (r 40 (r 206 40)) (r (r 206 40) (r 40 (r 206 40))))
;(r (r 206 40) (r 40 (r 206 40)))
;合計18回r(=reminder)を評価したことになる。
