;現時点で使用できる手続きの表現力は限定されている。なぜなら、テストを行いそのテストの結果に従って
;違う処理を行う方法がないからだ。
;
;例えば、数の絶対値を求める手続きを定義できない。これは、与えられた数が負数、0、整数によって返す値を
;変更する必要があるからだ。
;
;これらは場合分け（case analysis）といい、lispではcondと呼ばれる特殊フォームによって
;記述することができる。

(define (abs x)
	(cond ((> x 0) x)
		((= x 0) 0)
		((< x 0) (- x))))
(print (abs -5))

;(cond (<p1> <e1>)
;	  (<p2> <e2>)
;	  (<p3> <e3>)
;	  (<pn> <en>))

;cond の次にclauses(節)という式の対を記述する。
;pはpredicate(述語)と呼ばれ、値を真か偽と解釈する式である。eは帰結式(consequent expression)と
;よばれ、predicateが芯であった場合、対応する帰結式を条件式の戻り値とする。

(define (abs x)
	(cond 
		((< x 0)(- x))
		(else x)))
(print (abs -8))

;さらに明示的にelseを使用せずに、
;(if <predicate> <consequent> <alternative>)という形式を使うこともできる

(define (abs x)
	(if (< x 0)
		(- x)
		 x))
(print (abs -4))

;基本的なpredicate(値を真か偽と解釈する式である)のほかに、andとor、notなどの論理複合述語もある

;(and <e1> <e2>...<en>)
;(or <e1> <e2>...<en>)
;(not <e>)

;andとorはspecial form(特殊フォーム)である、子要素は必ずしも評価されない。
;notは通常のprocedureである

(define (>= x y)
  (or (> x y) (= x y)))

(print (>= 10 2))

(define (>= x y)
  (not (< x y)))

(print (>= 10 22))

; exercise 1.3
; 三つの数を引数としてとり、大きい二つの数の二乗の和を返す手続きを定義せよ

(define (biggertwo x y z)
		(if (< x y)
			(+ (* y y)
				(if (< x z)
					(* z z)
					(* x x)))
			(+ (* x x) 
				(if (< y z)
					(* z z)
					(* y y)))))
(print (biggertwo 3 4 5))
; 16 + 25 = 41

; exercise 1.4 
; 演算子が合成式()である組み合わせでも、これまで見てきた評価モデルが使用できるか？下記の手続きを説明する

; ------- 1-1-6 
;合成手続きはどのように解釈系で評価されるか？
;組み合わせの評価とほとんど同じで、組み合わせの要素を評価し、手続きを引数に作用させる

;合成手続きを引数に作用させるには、
;(1)仮パラメタを対応する引数で取り替え
;(2)手続きの本体を評価する
; -------

(define (a-plus-abs-b a b)
	((if (> b 0) + -) a b))
(print (a-plus-abs-b 4 -5))

; (if (> -5 0) + -) 4 -5)
; (- 4 -5)
; (+ 4 5)
; + 9

; exercise 1.5

;Ben Bitdiddleは自分が使っているインタプリタが
;作用的順序(Applicable order)か正規順序(Normal Order)の評価を使っている
;かを確認する手順を考案した


;作用的順序(applicative Order)と正規順序(normal order)は下記の違いがる

;作用的順序(applicative Order) => 置き換えモデル

;最初に演算子と被演算子を評価して、結果として表れる手続きを結果として表れる引数に適応する。
;Lispではパフォーマンス(Normal Orderでは結果が同じになる演算も複数回行われる)と、
;置き換えモデルで対処できない手続きを評価するのが複雑になることから、作用的順序(applicative Order)
;を使用している。

;(f 5)
; => fの本体を取り出す
;(sum-of-squares (+ a 1) (* a 2))
; => 形式パラメーター(formal parameter)のaを、引数の5と置き換える 
;(sum-of-squares (+ 5 1)(* 5 2))
; => オペレータの展開(square)、引数の評価、形式パラメーターとの置き換え
;(+ (square 6)(square 10))
;(+ (* 6 6)(* 10 10))
;(+ 36 100)
;136

;正規順序(normal order) => 被演算子については値が必要になるまで評価しない

;置き換えによって、基本式のみになるまで演算子を完全に展開し、その後被演算子を評価(reduce)する

;(f 5)
;(sum-of-squares (+ a 1) (* a 2))
;(sum-of-squares (+ 5 1)(* 5 2))
;(+ (square (+ 5 1))(square (* 5 2)))
;(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
;(+ (* 6 6)(* 10 10))
;(+ 36 100)
;136


;まず、下記のような手続きを定義する

(define (p) (p))

(define (test x y)
	(if (= x 0)
		0
		y))
		
;そして、下記の式を評価する

(test 0 (p))

;この場合、それぞれのインタープリタはどのように振る舞うであろうか？
;作用的順序でも、正規順序でも特殊フォームのifは同じように評価されることを前提とする
;つまり、まず条件式が評価され、その結果により真の場合の式を評価するか偽の場合の式が評価されるかが決定される。

;作用的順序(Applicable Order)

;(test 0 (p))

;=>まず演算子と被演算子を評価する
;pが無限に評価されるため、無限ループに陥る

;正規順序(Normal Order)

;=>置き換えによって、基本式のみになるまで演算子を完全に展開する

;(test 0 (p))

;(if (= 0 0)
;	0
;	(p))

;=>その後reduceするが、pは評価しない
;0


