;1.3 Formulating Abstractions with Higher-Order Procedures

;これまで手続きを、特定の数値に依存しない複合した操作を抽象化したものとして見てきた。

(define (cube x)(* x x x))

;このように書くと、特定の立方体について体積を求めるのではなく、
;どのようなサイズの立方体の体積も求めることができる。

;もちろんこうした手続きを用いないで、逐一下記のような式を使用
;することで求める事もできる
;(* 3 3 3)
;(* x x x)
;(* y y y)

;ただこうすると、常にたいてい言語のプリミティブ(この場合は乗算)のレベルで
;特定の演算を考えないといけないという状況を作り出し、高次元での手続きで
;考えることが難しくなる。作ったプログラムは確かに立方体の体積を求められるが、
;そこに表した言語では「立方体の体積を求める」という概念を表現できていないことになる。
;強力なプログラミング言語に求めるべきことは共通のパターンに名前を割り当てて抽象化できること、
;さらにその抽象レベルで考えれるようにすることだ。手続きはこの機能を提供する。
;ゆえに、本当に原始的なプログラミング言語以外では手続きを定義するメカニズムが用意されている。

;しかし、手続きのパラメーターに数字しか使用できないとなると、数値の計算でさえも我々の抽象化を
;行う能力はかなり制限されるだろう。同じプログラミングのパターンが異なる手続きで使用されることは
;しばしばある。こうしたパターンをコンセプトとして表現するには、手続自体を引数にとったり
;戻り値として手続きを返したりする手続きを定義できる必要がある。
;こうした手続を操作する手続きをhiger-order procedure(高階手続き)という。
;以下のセクションでは、高階手続きをどのようにして強力な抽象化のメカニズムとして使用し、
;言語の表現力を大幅に拡張できるか提示する。

;1.3.1 引数としての手続き

;下記の3つの手続きを考えてみる。
;1つめはaからbの整数の合計を計算する。

(define (sum-integer a b)
    (if (> a b)
        0
        (+ a (sum-integer (+ a 1) b))))
(print (sum-integer 2 5))

;2番目は、与えられた範囲の整数の3乗の合計を計算する
(define (sum-integer-cube a b)
    (if (> a b)
        0
        (+ (* a (* a a)) (sum-integer-cube (+ a 1) b))))
(print (sum-integer-cube 2 5))

;3つめは、1 / (1 * 3) + 1 / (5 * 7) + 1 / (( * 9 11) という
;連続の数の合計を求める(これはπ/8に収束する)

(define (pi-sum a b)
    (if (> a b)
        0
        (+ (/ 1 (* a (+ a 2)))(pi-sum (+ a 4) b))))
(print (pi-sum 2 5))

;これらの手続きは明らかに共通のパターンを有している。
;これらはほとんどすべての場所で同一であり、違うのは手続き名
;と計算対象のaを表現する箇所、そして次のaを表現する部分のみである。
;同じテンプレートでパラメーターを変えるだけでいずれの手続きも作れてしまう。

;(define (<name> a b)
;    (if (> a b)
;        0
;        (+ (<term> a)
;           (<name> (<next> a)b))))

;こうした共通のパターンが存在するということは、有用な抽象化が実装できること
;を示している。
;実際、一連の数字の合計を抽象化できることを数学者は随分昔に発見し、
;シグマ記号を発明した。

;bΣn=a f(n) = f(a) + ... + f(b)

;シグマ表記のなにが強力かと言えば、これによって数学者たちは
;特定の合計値だけではなく、総和自体の概念を扱えるようになった。
;例えば、総和の対象となる特定の数の連なりに依存しない、一般的な
;総和の計算結果を公式化できるようになった。

;同様にプログラムの設計者として、特定の総和を求める手続きを書くのではなく
;総和という概念自身の手続きをかけるように、強力な言語を作りたいと思うだろう。
;すでに我々の手続き的な言語でも、上記の共通テンプレート内のスロットを
;公式なパラメーターに変換することで実現できる。

(define (sum term a next b)
    (if (> a b)
        0
        (+ (term a)
           (sum term (next a) next b))))

;termは数列の一つの要素の値を求める手続き、
;nextは数列の次の要素を求める手続き、となる。
;例えば、与えられた範囲の数値の立方体を合計する2番目の手続きを適用すると

(define (inc a)(+ a 1))  ; next
(define (sum-cubes a b)  ; termはcube(組込み関数)
    (sum cube a inc b))
(print (sum-cubes 2 5))

;与えられた範囲の数値を単純に合計する1番目の手続きは
;termが数値の値をそのまま返せば良い。nextは範囲を順々に返せばいいので、上と同じ

(define (identity x)x)  ; term
(define (sum-integer2 a b)
    (sum identity a inc b))
(print (sum-integer2 2 5))

;pi-sumも同様に定義できる。

(define (pi-term a)(/ 1 (* a (+ a 2))))
(define (pi-next a)(+ a 4))
(define (pi-sum2 a b)
    (sum pi-term a pi-next b))
(print (pi-sum2 2 5))

;(pi-sumの結果がπ/8に収束するという性質を利用して)、これらの手続きを
;使用して、πの近似値を得ることもできる。

(print (inexact (* 8 (pi-sum 1 1000))))

;sumというテンプレートができたことで、さらに概念を公式化するビルディング
;ブロックとして使用出来る。たとえば、aからbの値に対する関数fの適用結果の
;定積分(definite integral)は下記の公式を使用して、数値的にはdxの小さい時の
;近似値が得られる。

;b∫a・f = [f(a + dx/2) + f(a + dx + dx/2) + f(a + 2dx + dx/2) + ..]dx

;定積分の数値計算(導入関数から求めるのではなく面積から近似値を得る)については、
;様々な公式があるが、上記は中点法(積分する区間をd等分して長方形を敷き詰めるのだが、その高さとしては
;区間の中間点= (a + dx/2) のものを使用する

;数値積分
;http://ja.wikipedia.org/wiki/%E6%95%B0%E5%80%A4%E7%A9%8D%E5%88%86

(define  (integral f a b dx)
  (define (add-dx x)(+ x dx))
  (* (sum f (+ a (/ dx 2.0)) add-dx b)
    dx))

(print (integral cube 0 1 0.01))
(print (integral cube 0 1 0.001))

;cubeの0から1の定積分は1/4である

;Exercise 1.29
;TODO

;Exercise 1.30
;TODO

;Exercise 1.31
;TODO

;Exercise 1.32
;TODO

;Exercise 1.33
;TODO
