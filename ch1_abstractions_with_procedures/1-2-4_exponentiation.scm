;1.2.4 exponentiation

;ある数のべき乗を計算するとする。基底となる数bと正の整数nを引数にとり
;b^nを計算する。

;一つのやり方は再帰的に定義を行うことだ。
; b^n = b * b^(n-1)
; b^0 = 1

;これは簡単に下記のような手続きに変換できる。

(define (expt b n)
  (if (= n 0)
    1
    (* b (expt b (- n 1)))))

(print  (expt 4 3))

;これは線形再帰の手続きで、Θ(n)ステップとΘ(n)の記憶容量を必要とする。
;フラクタルの場合と同じように、すぐに線形反復の形式に変換できる。

;***
; exptは線形反復を呼び出しているだけ。
; expt-iterでは,べき乗をb^n = b * b^(n-1)という定義にそって
; 計算するのではなく、 n回ループして b * product を実行するという考え方。
; 計算途中の結果を保持するproductというパラメータを関数に渡していくことで、
; 内部変数の代わりに使用し再帰呼び出しでループを実現する。
;***

(define (expt b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
     product
     (expt-iter b 
      (- counter 1)
      (* b product)))) 

(print (expt 4 3))

;この線形反復の場合はΘ(n)ステップとΘ(1)の記憶容量である。
;逐次平方を使用することで、べき乗をより少ないステップで計算することができる
;例えば、b^8を
;b・(b・(b・(b・(b・(b・(b・b))))))
;のように計算する代わりに、3回掛け算を使用して計算できる。
;b^2 = b * b
;b^4 = b^2 * b^2
;b^8 = b^4 * b^4

;この方法は2のべき乗が指数の場合にうまく働く。
;下記のようなルールを使用すれば、逐次平方を利用した
;べき乗を計算を一般化できる。

;b^n = (b^(n/2))^2 ;nが偶数の場合
;b^n = b * b^(n-1) ;nが奇数の場合

;これは手続きとしては下記のように表現できる。

(define (fast-expt b n)
  (cond ((= n 0)1)
    ((even? n) (square (fast-expt b (/ n 2))))
    (else (* b (fast-expt b (- n 1))))))

;整数が遇数であるかを判定する述語は、基本手続き(primitive procedure)のremainderを
;使用して定義できる。

(define (even? n)
  (= (remainder n 2)0))

(define (square n)
  (* n n))

(print (fast-expt 4 2))

;fast-exptによる手続きは、記憶容量からいってもステップ数からいっても
;nに対数的(logarithmically)に増加する。
;これを理解するには、fast-exptを使用する場合、b^2nを計算するためには
;b^nに比べて掛け算がひとつ多いだけであることに着目すればよい。
;つまり、新たに掛け算の計算回数が増えるたびに、(おおよその)
;計算できる指数の大きさが2倍になる。したがって、nのべき乗を計算
;するために必要な掛け算の回数は、2を底とするnの対数程度に増加する。
;そのため、手続きの計算量はΘ(log n)である。

;* 「2を底とするnの対数」とは、指数関数の定義で言えば、p = log2 nで示すところのp
;* であるが、「2を??乗すればnになるか」の??にあたる数字。


