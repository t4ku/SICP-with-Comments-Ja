;1.2.4 exponentiation

;ある数のべき乗を計算するとする。基底となる数bと正の整数nを引数にとり
;b^nを計算する。

;一つのやり方は再帰的に定義を行うことだ。
; b^n = b * b^(n-1)
; b^0 = 1

;これは簡単に下記のような手続きに変換できる。

(define (expt b n)
  (if (= n 0)
    1
    (* b (expt b (- n 1)))))

(print  (expt 4 3))

;これは線形再帰の手続きで、Θ(n)ステップとΘ(n)の記憶容量を必要とする。
;フラクタルの場合と同じように、すぐに線形反復の形式に変換できる。

;***
; exptは線形反復を呼び出しているだけ。
; expt-iterでは,べき乗をb^n = b * b^(n-1)という定義にそって
; 計算するのではなく、 n回ループして b * product を実行するという考え方。
; 計算途中の結果を保持するproductというパラメータを関数に渡していくことで、
; 内部変数の代わりに使用し再帰呼び出しでループを実現する。
;***

(define (expt b n)
  (expt-iter b n 1))

(define (expt-iter b counter product)
  (if (= counter 0)
     product
     (expt-iter b 
      (- counter 1)
      (* b product)))) 

(print (expt 4 3))

;この線形反復の場合はΘ(n)ステップとΘ(1)の記憶容量である。
;逐次平方を使用することで、べき乗をより少ないステップで計算することができる
;例えば、b^8を
;b・(b・(b・(b・(b・(b・(b・b))))))
;のように計算する代わりに、3回掛け算を使用して計算できる。
;b^2 = b * b
;b^4 = b^2 * b^2
;b^8 = b^4 * b^4

;この方法は2のべき乗が指数の場合にうまく働く。
;下記のようなルールを使用すれば、逐次平方を利用した
;べき乗を計算を一般化できる。

;b^n = (b^(n/2))^2 ;nが偶数の場合
;b^n = b * b^(n-1) ;nが奇数の場合

;これは手続きとしては下記のように表現できる。

(define (fast-expt b n)
  (cond ((= n 0)1)
    ((even? n) (square (fast-expt b (/ n 2))))
    (else (* b (fast-expt b (- n 1))))))

;整数が遇数であるかを判定する述語は、基本手続き(primitive procedure)のremainderを
;使用して定義できる。

(define (even? n)
  (= (remainder n 2)0))

(define (square n)
  (* n n))

(print (fast-expt 4 2))

;fast-exptによる手続きは、記憶容量からいってもステップ数からいっても
;nに対数的(logarithmically)に増加する。
;これを理解するには、fast-exptを使用する場合、b^2nを計算するためには
;b^nに比べて掛け算がひとつ多いだけであることに着目すればよい。
;つまり、新たに掛け算の計算回数が増えるたびに、(おおよその)
;計算できる指数の大きさが2倍になる。したがって、nのべき乗を計算
;するために必要な掛け算の回数は、2を底とするnの対数程度に増加する。
;そのため、手続きの計算量はΘ(log n)である。

;* 「2を底とするnの対数」とは、指数関数の定義で言えば、p = log2 nで示すところのp
;* であるが、「2を??乗すればnになるか」の??にあたる数字。

;Θ(log n)とΘ(n)の増加率の違いはnが大きい数になるほど際立ってくる。
;例えば、fast-exptをn = 1000で計算すると14回の乗算しか必要とならない。
;また、逐次平方の考え方を用いて、対数的に増加するステップ数でべき乗を計算する
;反復的アルゴリズムも考えられるが(exercise 1.16)、反復的アルゴリズムによくある
;ように再帰的アルゴリズムのようにはわかりやすくならない。

;Exercise 1.16

;逐次平方を用い、fast-exptのように対数的なステップ数でかつ、
;反復的なべき乗計算のプロセスを展開する手続きを設計せよ。
;(ヒント: (b^(n/2))^2 = (b^2)^(n/2)という関係とともに、べき乗数n、底b、そして
;状態変数のaを使用する。そしてa * b^nが変化しないような変形を定義する。
;aは1から始まり、手続きが終了した段階で答えの値(べき乗数)になる。
;一般的に、状態が変化しても同じ値をとり続ける不変量(invariant quantity)を定義
;するというテクニックは反復的アルゴリズムを考える上で強力な方法である。)

;***
; 簡単な数値でロジックの確認をしてみる。
; 2^6 (= 64)を考えてみる

; b=2,n=6として計算する(a=1) 
; (2^(6/2))^2 = (2^2)^(6/2) = 4^3であるから次に
;
; b=4,n=3として計算する。(a=1)
; 4^3の場合は3は2で割り切れないから、4*4^2となり、
; 最初の4はaに外出しでき、4^2の部分を次に考える。
;
; b=4,n=2として計算をする(a=1*4)
; (4^(2/2))^2 = (4^2)^1 = 16^1であるから次に
;
; b=16,n=1として計算する(a=1*4)
; 16^1の場合は1が2で割り切れないから、16*16^0となり、
; 最初の16はaに外出しでき、16^0の部分を次に考える
;
; b=16,n=0として計算する(a=1*4*16)
; n = 0の時、b^nは1となるのでこれが終了条件でよさそう
;
; 以上の結果、nが奇数である場合のターンでb^2がaに
; 外出しできるのがわかる。
; 
;***

(print "--exercise 1.16--")

(define (fast-expt-inv b n a)
  (cond 
    ((= n 0) a)
    ((even? n)
      (fast-expt-inv 
        (* b b) 
        (/ n 2)
        a))
    (else
      (fast-expt-inv
        b
        (- n 1)
        (* a b)))))

(print (fast-expt-inv 5 3 1))

;Exercise 1.18

;このセクションで扱ったべき乗計算のアルゴリズムは、
;掛け算の繰り返しを行うことで指数を計算するものである。
;同じように、整数の乗算は、加算の繰り返しを行うことで計算できる。
;下記の乗算を行う手続きは手続きexptを乗算に適用したものである。

(define (* a b)
  (if (= b 0)
    0
    (+ a (* a (- b 1)))))

;このアルゴリズムはbに線形に増加するステップを要する。
;今、加算と、整数を2倍に変換するdoubleと、偶数を2で割った商を返すhalve
;というオペレーターがあるとする。
;これらを用いて、対数的に増加するステップで乗算を行う、fast-exptに
;類似した手続きを設計せよ。

;***
;a*bという演算を、反復的アルゴリズムで実装するためには
;b=0になるまで、a+(a+(a+(...)))をくり返していけばよい。
;
;ただし、問題はfast-exptの乗数版なので、逐次平方ならぬ逐次2分割
;のようにして、計算量をΘ(n)ではなくてΘ(log n)に抑える必要がある。
;下葉ってb=1になるまで下記の演算を行えば良い。
;
;a*b = a+a*(b-1) ; 奇数の場合、a+fn(a*(b-1))を呼び出し
;a*b = a*2*(b/2) ; 偶数の場合、fn(2a * b/2)を呼び出し
;***

(print "--exercise 1.17--")

(define (fast-multi-recur a b)
  (cond ((= b 1) a)
  ((even? b) (fast-multi-recur (double a) (halve b)))
  (else (+ a (fast-multi-recur a (- b 1))))))

(define (halve n)
  (/ n 2))
(define (double n)
  (* n 2))

(print (fast-multi-recur 3 5))

;Exercise 1.18

;Exercise 1.16/1.17の結果を利用して、加算、2倍(double)、1/2(halve)
;を使用して反復的手続きを形成し、対数的に増加するステップで
;２つの整数を乗算する手続きをかけ。
;
;***
;下記のように全問と基本的には考え方は同じだが、反復的にするために
;加算に変換されたaの合計をsumという状態変数に入れておき、b=0になった時点
;で(再帰呼び出しの収縮をしなくても)答えが求まる
;b=0になるまで繰り返し
;a*b = a+a*(b-1) ; 奇数の場合
;a*b = a*2*(b/2) ; 偶数の場合
;***

(print "--exercise 1.18--")

(define (fast-multi a b sum)
  (cond 
    ((= b 0) sum)
    ((even? b) (fast-multi a (halve b) (double sum)))
    (else (fast-multi a (- b 1) (+ sum a)))))

(print (fast-multi 3 5 0))

;Exercise 1.19

;フィボナッチ数を対数的に増加するステップで計算する賢いアルゴリズムが存在する。
;1.2.2で見たfib-iterという手続きで状態変数のaとbがどのように変形していったかを
;思い出して欲しい。

; a <- a + b
; b <- a

;***
;fib-iterはフィボナッチ数を定義通りに手続き化した再帰手続きではなく,
; fib(1) = 1, fib(0) = 0から初めて、任意の数nについてのフィボナッチ数を
; 求めるためには、上記のような変形をn回適用すればよいという反復手続きだった。
; a = fib(1)
; b = fib(0)
;***

;この変形をTとよび、Tをa = 1 b = 0からn回適用すると、fib(n+1)とfib(n)が求まる。
;言い換えると、フィボナッチ数はT^n、つまり変形Tのn乗を(1,0)というペアに適用する
;ことで求められる。

;ここで、Tpqは(a,b)を
; a <- bq + aq + ap
; b <- bp + aq
;のようにペアの値を計算する変形だとして、Tはその変形において
;p = 0 かつq = 1であるときのケースを表すものであるとする。

;このようなTpqという変形を2回適用させた場合と同じ効果をもつ
;Tp'q'が存在することを示し、p',q'をp,qを用いて表せ。

;これによって変形を2乗する方法が得られ、fast-exptの手続きのように
;Tnを逐次平方で計算できる。

;これらをすべてをまとめて、対数的に増加するステップで動作する下記
;の手続きを完成させろ。


;(define (fib n)
;  (fib-iter 1 0 0 1 n))
;(define (fib-iter a b p q count)
;  (cond ((= count 0) b)
;        ((even? count)
;         (fib-iter a
;                   b
;                   <??>      ; compute p'
;                   <??>      ; compute q'
;                   (/ count 2)))
;        (else (fib-iter (+ (* b q) (* a q) (* a p))
;                        (+ (* b p) (* a q))
;                        p
;                        q
;                        (- count 1)))))

;***
;なぜ、
; a <- a + b
; b <- a
;という変形に
; a <- bq + aq + ap
; b <- bp + aq
;という係数つきの変形を持ち込み、p = 0 かつq =1という条件を設定するのか？
;
;フィボナッチ数列の連続を、行列の積によって求める過程と捉える。
;Fast Fibonacci Number Matrix Calculation
;https://github.com/psholtz/MIT-SICP/wiki/Fast-Fibonacci-Number-Matrix-Calculation
;
;一般に行列の積は、行と列の積の和として求められる。
;| a b |  | e f |
;| c d |  | g h |
;上記の積は、
;| ae + bg  af + bh | 
;| ce + dg  cf + dh | 
;となる。
;
;連続するフィボナッチ数の行列を
;| Fa |
;| Fb |
;という行列で表した時に、
;| F(a+1) |
;| F(b+1) |
;を積によって導き出すための行列はどのようなものになるか考えてみる。

;  | 0 |  | 1 |
;  | 1 |  | 1 |

;  | 1 |  | 1 |
;  | 1 |  | 2 |

;  | 1 |  | 2 |
;  | 2 |  | 3 |

;まず、1x2の行列ではa*0 + a*1 = 1 , b*0 + b*1 = 1からa = 1, b =1となり、その後の計算が辻褄が合わない。
;少なくとも2x2以上の行列であるはず。
;そこで対象の行列を下記のように想定する。

;| a b |
;| c d |

;まず最初の0,1 => 1,1の変換が
; a*0 + b*1 = 1
; c*0 + d*1 = 1
;から、b = 1, d =1と置ける

;| a 1 |
;| c 1 |

;次の1,1 => 1,2は
; a*1 + 1*1 = 1
; c*1 + 1*1 = 2
; から、a = 0 , c = 1と置け、求める変換行列は
;下記であることがわかる。

; | 0 1 |
; | 1 1 |


;問題文にある、下記の変形は
; a <- bq + aq + ap
; b <- bp + aq
; 下記の行列a,bに対してどのような行列の積を求めるのか
; という観点で整理すると。
;| a |
;| b |

; a <- a(p + q) + b*q
; b <- a*q      + b*p

;| p + q  q |
;| q      p |
;となり、これが変形Tの行列定義である。

;ここで、問題は変形Tを2回適応する行列をpとqを用いて表せることを
;示してそれを使用してフィボナッチ数を求めるプログラムを完成させろといっている。

;ちなみに、下記のようにより大きい数を行列の2行目に持ってくる場合と
;| 1 |
;| 2 |

;| 2 |
;| 1 |
;のようにより大きい数を1行目に持ってくる場合で、変形Tの行数も変わるので注意。

;*** 

; | 1 | | 1 1 |
; | 0 | | 1 0 |
;
; 1*1 + 0*1
; 1*1 + 0*0 

; | 1 |
; | 1 |

; Tは下記の行列で表せるので、これを二乗すると
;| p + q  q |
;| q      p |

;| p + q  q | | p + q  q | 
;| q      p | | q      p | 

;| (p+q)*(p+q) + q^2   q(p+q) + qp |
;| q(p+q) + pq         q^2    + p^2|

;|  p^2 + 2pq + 2q^2    2pq + q^2  |
;|  q^2 + 2pq           q^2 + p^2  | 

;したがって、フィボナッチ数を2回求める変形T'は
; q = 2pq + q ^2
; p = p^2 + q ^2
;となる

(define (fib n)
  (fib-iter 1 0 0 1 n))
(define (fib-iter a b p q count)
  (cond ((= count 0) b)
        ((even? count)
         (fib-iter a
                   b
                   (+ (* 2 (* p q)) (* q q))      ; compute p'
                   (+ (* p p ) (* q q))      ; compute q'
                   (/ count 2)))
        (else (fib-iter (+ (* b q) (* a q) (* a p))
                        (+ (* b p) (* a q))
                        p
                        q
                        (- count 1)))))

(print "--exercise-1.19--")
(print (fib 12))
